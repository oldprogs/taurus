<html>
<head>
<META NAME="author" CONTENT="Dima Maloff">
<META NAME="description" CONTENT="Описание binkp (довольно поверхностное).">
<META NAME="keywords" CONTENT="binkp, description, binkd, описание, docs, doc, documentation">
<META HTTP-EQUIV="Content-language" CONTENT="ru">
<title>binkp</title>
</head>
<body>
<h1>Binkp/1.0</h1>

<hr>

<h2>Описание протокола</h2>

Binkp работает через двунаправленный символьный канал, не допускающий
ошибок при передаче даннных. Любые данные, записываемые каждой из сторон
в канал, имеют следующий общий формат:

<pre><tt>
   binkp's frames:

    +---------------------- 0=data block, 1=message(command)
    |                +---- data block size / msg's argument size
    |                |
    7 6543210 76543210
   +-+-------+--------+--- ..... ---+
   | |   HI      LO   |             | -- data block / msg's argument
   +-+-------+--------+--- ..... ---+
   |<-    2 bytes   ->|<- 32K max ->|

</tt></pre>


Заголовок кадра -- два байта, определяющие тип и длину (в байтах)
данных, следующих за заголовком.  Если старший бит заголовка сброшен,
то все данные поступившие с кадром следует дописать к текущему принимаемому
файлу. (Если такой файл уже открыт, иначе -- отбросить)
В противном случае, данные следует разобрать как команду, меняющую
состояние протокола. Первый байт данных, поступивших с кадром -- номер
команды. Оставшиеся -- аргумент. Аргументы команд -- произвольный набор
символов, не обязательно ограниченный <tt>'\0'</tt>. Команда без аругментов
(например, <a href="#M_OK">M_OK</a>) может выглядеть примерно так:

<pre><tt>
    7 6543210 76543210 76543210
   +-+-------+--------+--------+
   |1|      0        1|       4|
   +-+-------+--------+--------+
    |                |        +----- номер команды (аргументов нет)
    |                +-------- длина кадра без заголовка -- 1 байт
    +- это команда
</tt></pre>

Команды, которые понимает binkd/0.8, и их аргументы:

<ul>
<li>
<a name="M_NUL">M_NUL</a>  0
  <p>
  Аргумент команды игнорируется (и, возможно, записывается в лог). Именно
  так передаем нодлистовую информацию, имя сисопа и т.д.
  <p>
  eg, <tt>"ZYZ Dima Maloff"</tt>
  <p>
<li>
<a name="M_ADR">M_ADR</a>  1
  <p>
  Список 5D адесов (через пробел)
  <p>
  eg, <tt>"2:5047/13@fidonet 2:5047/0@fidonet"</tt>
  <p>

<li>
<a name="M_PWD">M_PWD</a>  2
  <p>
  Пароль. После успешной обработки пароля, принятого от remote,
  binkd-сервер пересканирует очередь.
  <p>
  eg, <tt>"pAsSwOrD"</tt>
  <p>

<li>
<a name="M_OK">M_OK</a>   4
  <p>
  Ответ на правильный пароль. binkd-клиент при приеме этого сообщения
  пересканирует очередь. Аргумент команды игнорируется.
  <p>
  eg, <tt>""</tt>
  <p>

<li>
<a name="M_FILE">M_FILE</a> 3
  <p>
  Данные о следующем файле. Через пробел: имя файла (без пробельных
  символов); размер; unix-time; смещение, с которого файл передается.
  Все -- в десятичной системе. Все следующие принятные блоки данных
  относятся именно к этому файлу до поступления следующего сообщения M_FILE.
  Специального признака конца файла нет, так как размер файла известен
  заранее. binkd "лишние" блоки допишет к концу текущего файла.
  Каждый новый файл мы начинаем передавать со смещения 0. Получение
  <a href="#M_GET">M_GET</a> от remote должно заставить нас сделать seek.
  <p>
  eg, <tt>"config.sys 125 2476327846 0"</tt>
  <p>
  Или, при ответе на M_GET со смещения 100:
  <p>
      <tt>"config.sys 125 2476327846 100"</tt>
  <p>


<li>
<a name="M_EOB">M_EOB</a>  5

  <p>
  End-of-Batch. EOB передается после того, как посланы все файлы.
  Если мы находимся в сосотоянии EOB (все файлы посланы), получаем от
  remote EOB (больше нет файлов для нас), мы получили все подтверждения
  на все посланные файлы, мы получили все файлы перезапрошенные по <a href="#M_GET">GET</a>,
  то сессия считается успешно завершенной.
  <p>
   eg, <tt>""</tt>
  <p>
  
<li>
<a name="M_GOT">M_GOT</a>  6
  <p>
  Передается принимавшей файл системой как подтверждение
  после получения последней порции данных файла. Аргументы
  копируют аргументы команды <a href="#M_FILE">FILE</a> от remote, за исключением последнего --
  смещения, который не возвращается на систему, передавшую <a href="#M_FILE">M_FILE</a>.
  GOT может быть передан и в процессе приема файла -- реакция на нее
  передающей стороны -- разрушающий skip.
  <p>
  eg, <tt>"config.sys 125 2476327846"</tt>
  <p>

<li>
<a name="M_ERR">M_ERR</a>  7
  <p>
  Фатальная ошибка. Сторона, передавшая M_ERR, завершает сессию.
  ргумент, текст объясняющий причину, пишется в лог. binkd передает
  M_ERR в ответ на неверный пароль.
  <p>
  eg, <tt>"Incorrect password"</tt>
  <p>

<li>
<a name="M_BSY">M_BSY</a>  8
  <p>
  Передается если наша система занята. Аргумент игнорируется принимающей
  стороной. (Записывается в лог)
  <p>
  eg, <tt>"Too many servers are running already" </tt>
  <p>

<li>
<a name="M_GET">M_GET</a>  9
  <p>
  С помощью M_GET делается resend. Аргументы M_GET копируют аргументы
  команды <a href="#M_FILE">M_FILE</a>, которую мы бы желали видеть от remote. :)
  Binkd посылает ее как ответ на <a href="#M_FILE">M_FILE</a> в том случае,
  если его не устраивает смещение с которого нам начали файл передавать.
  <p>
  eg, <tt>"config.sys 125 2476327846 100"</tt>
  <p>
  Сейчас binkd обрабатывает ее так: по первым полям (имя/размер/unixtime)
  определяет, является ли аргумент M_GET текущим для нас передаваемым
  файлом (либо файл уже передан и мы ждем для него <a href="#M_GOT">M_GOT</a>),
  и если это так, делает seek на заданное смещение, после чего
  послылает <a href="#M_FILE">M_FILE</a>. Для нашего примера
  <a href="#M_FILE">M_FILE</a> будет иметь аргументы:
  <p>
      <tt>"config.sys 125 2476327846 100"</tt>
  <p>

<li>
<a name="M_SKIP">M_SKIP</a> 10
  <p>
  Неразрушающий skip.
  Пример строки пареметров:
  <p>
      <tt>"config.sys 125 2476327846"</tt>
</ul>

<h2>Типичная сессия между двумя binkd</h2>
<table border>
<tr><th>
      вызвающая система посылает     <th> вызываемая система посылает
</tr>
<tr><td>      M_NUL "SYS ..."          <td>   M_NUL "SYS ..."</tr>
<tr><td>      M_NUL "ZYZ ..."          <td>       M_NUL "ZYZ ..."</tr>
<tr><td>      M_NUL "LOC ..."          <td>       M_NUL "LOC ..."</tr>
<tr><td>      M_NUL "VER ..."          <td>       M_NUL "VER ..."</tr>
<tr><td>      M_ADR "2:2/2.2@fidonet"  <td>       M_ADR "3:3/3.3@fidonet"</tr>
<tr><td>      M_PWD "password"         <td>       (ждем пароля от remote)</tr>
<tr><td>                         <td> M_OK "" или M_ERR "Bad password"</tr>
<tr><td>      (ждем M_OK)        <td>             M_FILE "file2 200 42342434 0"</tr>
<tr><td>      M_FILE "file1 100 423424244 0"<td>  data</tr>
<tr><td>      data                          <td>  data</tr>
<tr><td>      data                          <td>  data</tr>
<tr><td>      M_EOB                         <td>  (получили file1 целиком, подтверждаем)</tr>
<tr><td>      (получили file2 целиком, подтверждаем)  <td>  M_GOT "file1 100 423424244"</tr>
<tr><td>      M_GOT "file2 200 42342434"    <td>  data </tr>
<tr><td>                                    <td>  M_EOB</tr>
</table>
<hr>
&copy; Copyright 1996-97
by <a href="http://www.corbina.net/~maloff/">Dima Maloff</a><br>
<i>$Id: binkp.html,v 1.5 1998/10/08 07:31:48 maloff Exp $</i>
</body>
</html>
